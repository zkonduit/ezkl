use ethereum_types::Address;
use foundry_evm::executor::{fork::MultiFork, Backend, ExecutorBuilder};
use halo2_proofs::poly::kzg::commitment::ParamsKZG;
use halo2curves::bn256::{Bn256, Fr};
use log::{debug, trace};
use rand::rngs::OsRng;
use serde::{Deserialize, Serialize};
use snark_verifier::loader::evm::encode_calldata;
use std::error::Error;
use std::fs::File;
use std::io::{Read, Write};
use std::path::PathBuf;
use thiserror::Error;

/// Aggregate proof generation for EVM
pub mod aggregation;
/// Simple (single) proof generation for EVM
pub mod simple;

#[derive(Error, Debug)]
/// Errors related to evm verification
pub enum EvmVerificationError {
    /// EVM execution errors
    #[error("EVM execution of raw code failed")]
    RawExecution,
    /// EVM verify errors
    #[error("evm verification reverted")]
    Reverted,
}

/// Defines the proof generated by a model / circuit suitably for serialization/deserialization.  
#[derive(Debug, Deserialize, Serialize)]
pub struct DeploymentCode {
    code: Vec<u8>,
}
impl DeploymentCode {
    /// Return (inner) byte code
    pub fn code(&self) -> &Vec<u8> {
        &self.code
    }
    /// Saves the DeploymentCode to a specified `path`.
    pub fn save(&self, path: &PathBuf) -> Result<(), Box<dyn Error>> {
        let serialized = serde_json::to_string(&self).map_err(Box::<dyn Error>::from)?;

        let mut file = std::fs::File::create(path).map_err(Box::<dyn Error>::from)?;
        file.write_all(serialized.as_bytes())
            .map_err(Box::<dyn Error>::from)
    }

    /// Load a json serialized proof from the provided path.
    pub fn load(path: &PathBuf) -> Result<Self, Box<dyn Error>> {
        let mut file = File::open(path).map_err(Box::<dyn Error>::from)?;
        let mut data = String::new();
        file.read_to_string(&mut data)
            .map_err(Box::<dyn Error>::from)?;
        serde_json::from_str(&data).map_err(Box::<dyn Error>::from)
    }
}

/// Verify by executing bytecode with instance variables and proof as input
pub fn evm_verify(
    deployment_code: Vec<u8>,
    instances: Vec<Vec<Fr>>,
    proof: Vec<u8>,
) -> Result<bool, Box<dyn Error>> {
    let calldata = encode_calldata(&instances, &proof);
    let mut evm = ExecutorBuilder::default()
        .with_gas_limit(u64::MAX.into())
        .build(Backend::new(MultiFork::new().0, None));

    let caller = Address::from_low_u64_be(0xfe);
    let verifier = evm
        .deploy(caller, deployment_code.into(), 0.into(), None)
        .map_err(Box::new)?
        .address;
    let result = evm
        .call_raw(caller, verifier, calldata.into(), 0.into())
        .map_err(|_| Box::new(EvmVerificationError::RawExecution))?;

    trace!("evm execution result: {:?}", result);
    debug!("gas used {}:", result.gas_used);

    if result.reverted {
        return Err(Box::new(EvmVerificationError::Reverted));
    }

    Ok(!result.reverted)
}

/// Generate a structured reference string for testing. Not secure, do not use in production.
pub fn gen_srs(k: u32) -> ParamsKZG<Bn256> {
    ParamsKZG::<Bn256>::setup(k, OsRng)
}
